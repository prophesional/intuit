
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/playground/interviews/intuit/clients.go (68.5%)</option>
				
				<option value="file1">github.com/playground/interviews/intuit/config.go (2.0%)</option>
				
				<option value="file2">github.com/playground/interviews/intuit/player.go (88.9%)</option>
				
				<option value="file3">github.com/playground/interviews/intuit/server.go (40.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package intuit

import (
        "database/sql"
        "encoding/csv"
        "fmt"
        "io/ioutil"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/go-sql-driver/mysql"

        _ "github.com/go-sql-driver/mysql"
        _ "github.com/mattn/go-sqlite3" // init mysql driver support
        "go.uber.org/zap"
)

type logger struct {
        *zap.Logger
}

func (l *logger) logError(err error, msg string) <span class="cov0" title="0">{
        l.Error(msg, zap.Error(err))
}</span>
func (l *logger) logInfo(msg string) <span class="cov0" title="0">{
        l.Info(msg)
}</span>

// SQLClient connects to the DB to perform operations
type SQLClient struct {
        *sql.DB
        *logger
        sqlType string
}

func NewLocalSqlClient(dbpath string, schema []string) (*SQLClient, error) <span class="cov8" title="1">{

        /*        path := filepath.Base(dbpath)
                fmt.Println("Path is ", path)
                _, noPathErr := os.Stat(path)

                fmt.Println("Path Error is ", noPathErr)

                if noPathErr != nil {
                        mkdirErr := os.MkdirAll(path, 0755)
                        if mkdirErr != nil {
                                fmt.Println("Mkdir error ", mkdirErr)
                                return nil, mkdirErr
                        }
                }*/
        if _, err := os.Create(dbpath); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">db, err := sql.Open("sqlite3", dbpath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">l, err := zap.NewProduction()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>
        <span class="cov8" title="1">client := &amp;SQLClient{
                DB:      db,
                logger:  &amp;logger{Logger: l},
                sqlType: "sqlite3",
        }

        for _, statement := range schema </span><span class="cov8" title="1">{
                if statement == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">_, err = db.Exec(statement)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return client, nil</span>

}
func NewLocalSqlClientWithFile(dbpath string, schemaFile string) (*SQLClient, error) <span class="cov8" title="1">{
        raw, err := ioutil.ReadFile(schemaFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">stmt := string(raw)

        var schema []string
        // separate the individual CREATE statements
        for idx := strings.Index(stmt, "CREATE"); idx &gt;= 0; idx = strings.Index(stmt, "CREATE") </span><span class="cov8" title="1">{
                next := strings.Index(stmt[idx+1:], "CREATE")
                if next &lt; 0 </span><span class="cov8" title="1">{
                        next = len(stmt) - 1
                }</span> else<span class="cov0" title="0"> {
                        next += idx + 1
                }</span>
                <span class="cov8" title="1">schema = append(schema, strings.TrimSpace(stmt[idx:next]))
                stmt = stmt[next:]</span>
        }

        <span class="cov8" title="1">return NewLocalSqlClient(dbpath, schema)</span>
}

// NewSQLClinet constructs a new SQL db client and connects to the database
func NewSQLClinet(config *SQLConfig) (*SQLClient, error) <span class="cov0" title="0">{
        logger := logger{}
        l, err := zap.NewProduction()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err

        }</span>
        <span class="cov0" title="0">logger.Logger = l
        c := SQLClient{}
        c.logger = &amp;logger

        connStr, err := config.ConnectionString()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db, err := sql.Open(config.Type, connStr)
        if err != nil </span><span class="cov0" title="0">{
                l.Error("cannot open sql connection", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">c.DB = db
        c.sqlType = config.Type
        return &amp;c, c.Ping()</span>
}

// GetPlayerById returns a player object from the db based on the playerId
func (c *SQLClient) GetPlayerById(id string) (*Player, error) <span class="cov8" title="1">{
        row, err := c.Query("SELECT * from Players where playerId  = ?", id)
        if row == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                c.logError(err, fmt.Sprintf("Error executing select statement for user id : %v", id))
                return nil, err
        }</span>
        <span class="cov8" title="1">var player *Player
        for row.Next() </span><span class="cov8" title="1">{
                player, err = c.convertRow(row)
        }</span>
        <span class="cov8" title="1">return player, err</span>
}

// GetAllPlayers returns all players currently in the database
func (c *SQLClient) GetAllPlayers() ([]*Player, error) <span class="cov8" title="1">{
        var players []*Player
        rows, err := c.Query("SELECT * from Players")

        if err != nil </span><span class="cov0" title="0">{
                c.logError(err, "Error executing select statement for user id")
                return nil, err
        }</span>

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                if player, err := c.convertRow(rows); err == nil </span><span class="cov8" title="1">{
                        players = append(players, player)
                }</span> else<span class="cov0" title="0"> {
                        c.logError(err, "error ocurred scanning row ")
                        continue</span>
                }
        }
        <span class="cov8" title="1">return players, nil</span>
}

// InsertPlayers inserts a batch of players into the Db
func (c *SQLClient) InsertPlayers(players []*Player) error <span class="cov8" title="1">{
        args := []interface{}{}
        sqlString := `INSERT into Players (PlayerID,BirthDate,BirthCountry,BirthState,BirthCity,DeathDate,DeathCountry,DeathState,DeathCity,NameFirst, 
                                 NameLast,NameGiven,Weight,Height,Bats,Throws,Debut,FinalGame,RetroID,BbrefID ) VALUES `

        for _, player := range players </span><span class="cov8" title="1">{
                deathDate := getSQLDate(player.DeathDate)
                debutDate := getSQLDate(player.Debut)
                finalGame := getSQLDate(player.FinalGame)
                values := fmt.Sprintf("(%v)", strings.Repeat("?,", 20))
                sqlString += values[0:len(values)-2] + "),"
                if player.DeathDate.IsZero() </span><span class="cov8" title="1">{
                        fmt.Println(player.DeathDate)
                        deathDate = nil
                }</span> else<span class="cov8" title="1"> {
                        deathDate = player.DeathDate
                }</span>
                <span class="cov8" title="1">args = append(args, player.PlayerID, player.BirthDate, player.BirthCountry, player.BirthState, player.BirthCity, deathDate, player.DeathCountry,
                        player.DeathState, player.DeathCity, player.NameFirst, player.NameLast, player.NameGiven, player.Weight, player.Height, player.Bats,
                        player.Throws, debutDate, finalGame, player.RetroID, player.BbrefID)</span>
        }
        <span class="cov8" title="1">updatedSQL := sqlString[0 : len(sqlString)-1]
        var upsertSQL string
        if c.sqlType != "sqlite3" </span><span class="cov0" title="0">{
                upsertSQL = updatedSQL + " ON DUPLICATE KEY UPDATE playerId=playerId"
        }</span> else<span class="cov8" title="1"> {
                upsertSQL = updatedSQL
        }</span>
        <span class="cov8" title="1">stmt, err := c.Prepare(upsertSQL)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer stmt.Close()
        _, err = stmt.Exec(args...)
        return err</span>

}

func getSQLDate(t time.Time) interface{} <span class="cov8" title="1">{

        if t.IsZero() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return t</span>
}

func (c *SQLClient) convertRow(rows *sql.Rows) (player *Player, err error) <span class="cov8" title="1">{
        player = &amp;Player{}
        var nullableDeathDate, nullableFinalGame mysql.NullTime
        var nullableDeathCity, nullableDeathState, nullableDeathCountry sql.NullString

        err = rows.Scan(&amp;player.PlayerID,
                &amp;player.BirthDate, &amp;player.BirthCountry, &amp;player.BirthState, &amp;player.BirthCity,
                &amp;nullableDeathDate, &amp;nullableDeathCity, &amp;nullableDeathState, &amp;nullableDeathCountry,
                &amp;player.NameFirst, &amp;player.NameLast, &amp;player.NameGiven,
                &amp;player.Weight, &amp;player.Height, &amp;player.Bats, &amp;player.Throws,
                &amp;player.Debut, &amp;nullableFinalGame,
                &amp;player.RetroID, &amp;player.BbrefID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if nullableDeathDate.Valid </span><span class="cov8" title="1">{
                player.DeathDate = nullableDeathDate.Time
        }</span>

        <span class="cov8" title="1">if nullableFinalGame.Valid </span><span class="cov8" title="1">{
                player.FinalGame = nullableFinalGame.Time
        }</span>

        <span class="cov8" title="1">if nullableDeathCity.Valid </span><span class="cov8" title="1">{
                player.DeathCity = nullableDeathCity.String
        }</span>

        <span class="cov8" title="1">if nullableDeathState.Valid </span><span class="cov8" title="1">{
                player.DeathState = nullableDeathState.String
        }</span>

        <span class="cov8" title="1">if nullableDeathCountry.Valid </span><span class="cov8" title="1">{
                player.DeathCountry = nullableDeathCountry.String
        }</span>

        <span class="cov8" title="1">return</span>
}

// Close closes the sql client
func (c *SQLClient) Close() <span class="cov0" title="0">{
        c.Close()
}</span>

// ingestion

func ConvertToPlayer(path string) ([]*Player, error) <span class="cov8" title="1">{

        var players []*Player
        f, err := os.Open(path) //parse if it starts with S3
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">lines, err := csv.NewReader(f).ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for i := 1; i &lt; len(lines); i++ </span><span class="cov8" title="1">{

                line := lines[i]

                weight, err := strconv.Atoi(line[16])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }
                <span class="cov8" title="1">height, err := strconv.Atoi(line[17])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }

                <span class="cov8" title="1">deathDate, err := getDate(line[7], line[8], line[9])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }
                <span class="cov8" title="1">birthDate, err := getDate(line[1], line[2], line[3])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }

                <span class="cov8" title="1">debutDate, err := parseDate(line[20])
                if err != nil </span><span class="cov8" title="1">{
                        fmt.Println(err)
                        continue</span>
                }
                <span class="cov8" title="1">finalGameDate, err := parseDate(line[21])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }

                <span class="cov8" title="1">player := &amp;Player{
                        PlayerID:     line[0],
                        BirthCountry: line[4],
                        BirthState:   line[5],
                        BirthCity:    line[6],
                        BirthDate:    birthDate,
                        DeathDate:    deathDate,
                        DeathCountry: line[10],
                        DeathState:   line[11],
                        DeathCity:    line[12],
                        NameFirst:    line[13],
                        NameLast:     line[14],
                        NameGiven:    line[15],
                        Weight:       weight,
                        Height:       height,
                        Bats:         line[18],
                        Throws:       line[19],
                        Debut:        debutDate,
                        FinalGame:    finalGameDate,
                        RetroID:      line[22],
                        BbrefID:      line[23],
                }

                players = append(players, player)</span>

        }

        <span class="cov8" title="1">return players, nil</span>

}

func getDate(year, month, day string) (time.Time, error) <span class="cov8" title="1">{
        if year == "" || month == "" || day == "" </span><span class="cov8" title="1">{
                return time.Time{}, nil
        }</span>

        <span class="cov8" title="1">dYear, err := strconv.Atoi(year)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        <span class="cov8" title="1">dMonth, err := strconv.Atoi(month)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">dDay, err := strconv.Atoi(day)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        <span class="cov8" title="1">if dYear == 0 || dMonth == 0 || dDay == 0 </span><span class="cov0" title="0">{
                return time.Time{}, nil
        }</span>
        <span class="cov8" title="1">return time.Date(dYear, time.Month(dMonth), dDay, 0, 0, 0, 0, time.UTC), nil</span>
}

func parseDate(d string) (time.Time, error) <span class="cov8" title="1">{

        date, err := time.Parse(layout, d)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">return date, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package intuit

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"

        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/secretsmanager"
        "go.uber.org/zap"

        "github.com/aws/aws-sdk-go/service/rds/rdsutils"
)

var log *zap.Logger

const (
        DefaultMaxOpenConnections = 10
)

func init() <span class="cov8" title="1">{
        log, _ = zap.NewProduction()

}</span>

type AWSConfig struct {
        Region          string `env:"AWS_REGION" cli:"aws-region"`
        AccessKeyID     string `env:"AWS_ACCESS_KEY" cli:"aws-access-key"`
        SecretAccessKey string `env:"AWS_SECRET_ACCESS_KEY" cli:"aws-secret-access-key"`
}

func (awsConfig *AWSConfig) GetAWSSession() (*session.Session, error) <span class="cov0" title="0">{
        if awsConfig.Region == "" </span><span class="cov0" title="0">{
                reg := os.Getenv("AWS_REGION")
                if reg == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AWS Region must be supplied to authenticate")
                }</span>
                <span class="cov0" title="0">awsConfig.Region = reg</span>
        }

        <span class="cov0" title="0">if awsConfig.SecretAccessKey == "" || awsConfig.AccessKeyID == "" </span><span class="cov0" title="0">{
                return session.NewSession(&amp;aws.Config{Region: aws.String(awsConfig.Region)})
        }</span>
        <span class="cov0" title="0">return session.NewSession(awsConfig.convertConfigs())</span>
}

func (awsConfig *AWSConfig) convertConfigs() *aws.Config <span class="cov0" title="0">{
        creds := credentials.Value{
                AccessKeyID:     awsConfig.AccessKeyID,
                SecretAccessKey: awsConfig.SecretAccessKey,
        }
        c := aws.Config{
                Region:      aws.String(awsConfig.Region),
                Credentials: credentials.NewStaticCredentialsFromCreds(creds),
        }
        return &amp;c
}</span>

type SQLConfig struct {
        ServerName   string `env:"DB_SERVER_NAME" cli:"db-server-name"`
        DatabaseName string `env:"DB_DATABASE_NAME" cli:"string-var"`
        UserName     string `env:"DB_DATABASE_USERNAME" cli:"string-var"`
        Password     string `env:"DB_DATABASE_PASSWORD" cli:"string-var"`
        /*MySQLConnStrOverride string        `env:"STRING_VAR" cli:"string-var"`
        MaxOpenConnections   int           `env:"STRING_VAR" cli:"string-var"`
        MaxIdleConnections   int           `env:"STRING_VAR" cli:"string-var"`
        ConnectTimeout       time.Duration `env:"STRING_VAR" cli:"string-var"`
        WriteTimeout         time.Duration `env:"STRING_VAR" cli:"string-var"`
        ReadTimeout          time.Duration `env:"STRING_VAR" cli:"string-var"`*/
        Type              string `env:"STRING_VAR" cli:"string-var"`
        AWSConfig         AWSConfig
        DatabaseSecretKey string `env:"STRING_VAR" cli:"string-var"`
}

type dbOptions struct {
        Username     string `json:"username"`
        Password     string `json:"password"`
        DatabaseName string `json:"databaseName"`
        Host         string `json:"host"`
}

func (c *SQLConfig) ConnectionString() (string, error) <span class="cov0" title="0">{
        //Use Secrets Manager for all settings
        if c.DatabaseSecretKey != "" </span><span class="cov0" title="0">{
                if dbOpts, err := c.getDBSecrets(); err == nil </span><span class="cov0" title="0">{

                        return c.getDBConnectionString(dbOpts), nil
                }</span> else<span class="cov0" title="0"> {
                        return "", err
                }</span>
        }
        //use IAM with RDS
        <span class="cov0" title="0">if c.UserName == "" || c.ServerName == "" || c.DatabaseName == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Username, ServerName and Database name are required for RDS access with IAM.  username: %v servername: %v databaseName: %v", c.UserName, c.ServerName, c.DatabaseName)
        }</span>
        <span class="cov0" title="0">var passwd string
        var err error
        if c.Password == "" </span><span class="cov0" title="0">{
                passwd, err = c.generateAuthToken()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        } else<span class="cov0" title="0"> {
                passwd = c.Password
        }</span>

        <span class="cov0" title="0">dbOpts := &amp;dbOptions{
                Password:     passwd,
                Username:     c.UserName,
                Host:         c.ServerName,
                DatabaseName: c.DatabaseName,
        }
        return c.getDBConnectionString(dbOpts), nil</span>

}

func (c *SQLConfig) generateAuthToken() (string, error) <span class="cov0" title="0">{
        session, err := c.AWSConfig.GetAWSSession()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if session == nil </span><span class="cov0" title="0">{
                return "", errors.New("nil AWS session detected")
        }</span>
        <span class="cov0" title="0">return rdsutils.BuildAuthToken(c.ServerName, c.AWSConfig.Region, c.UserName, session.Config.Credentials)</span>
}

func (c *SQLConfig) getDBSecrets() (*dbOptions, error) <span class="cov0" title="0">{

        s, err := c.AWSConfig.GetAWSSession()
        if err != nil </span><span class="cov0" title="0">{
                log.Error("error occurred getting session: %s ", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">secretsClient := secretsmanager.New(s)
        secretsInput := &amp;secretsmanager.GetSecretValueInput{
                SecretId: aws.String(c.DatabaseSecretKey),
        }

        result, err := secretsClient.GetSecretValue(secretsInput)

        if err != nil </span><span class="cov0" title="0">{
                log.Error(fmt.Sprintf("error occurred getting secret value %s", c.DatabaseSecretKey), zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">var dbOpts dbOptions
        err = json.Unmarshal([]byte(*result.SecretString), &amp;dbOpts)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("error occurred while unmarshalling secret string ", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;dbOpts, nil</span>
}

func (c *SQLConfig) getDBConnectionString(options *dbOptions) string <span class="cov0" title="0">{
        return fmt.Sprintf("%v:%v@tcp(%v)/%v?parseTime=true&amp;allowCleartextPasswords=true&amp;tls=false",
                options.Username,
                options.Password,
                options.Host,
                options.DatabaseName)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package intuit

import (
        "encoding/json"
        "time"
)

const (
        layout = "2006-01-02"
)

type Player struct {
        PlayerID     string `json:"playerId"`
        BirthDate    time.Time
        BirthCountry string
        BirthState   string
        BirthCity    string
        DeathDate    time.Time
        DeathCountry string
        DeathState   string
        DeathCity    string
        NameFirst    string
        NameLast     string
        NameGiven    string
        Weight       int
        Height       int
        Bats         string
        Throws       string
        Debut        time.Time
        FinalGame    time.Time
        RetroID      string
        BbrefID      string
}

func (p Player) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        deathY, deathM, deathD := p.getDeathDates()
        birthY, birthM, birthD := p.getBirthDates()
        return json.Marshal(
                &amp;struct {
                        PlayerID     string `json:"playerId"`
                        BirthDate    *int
                        BirthYear    *int
                        BirthMonth   *int
                        BirthCountry string
                        BirthState   string
                        BirthCity    string
                        DeathDate    *int
                        DeathYear    *int
                        DeathMonth   *int
                        DeathCountry *string
                        DeathState   *string
                        DeathCity    *string
                        NameFirst    string
                        NameLast     string
                        NameGiven    string
                        Weight       int
                        Height       int
                        Bats         string
                        Throws       string
                        Debut        string
                        FinalGame    string
                        RetroID      string
                        BbrefID      string
                }{
                        PlayerID:     p.PlayerID,
                        BirthDate:    birthD,
                        BirthYear:    birthY,
                        BirthMonth:   birthM,
                        BirthCountry: p.BirthCountry,
                        BirthState:   p.BirthState,
                        BirthCity:    p.BirthCity,
                        DeathDate:    deathD,
                        DeathMonth:   deathM,
                        DeathYear:    deathY,
                        DeathCountry: getString(p.DeathCountry),
                        DeathCity:    getString(p.DeathCity),
                        DeathState:   getString(p.DeathState),
                        NameGiven:    p.NameGiven,
                        NameLast:     p.NameLast,
                        NameFirst:    p.NameFirst,
                        Weight:       p.Weight,
                        Height:       p.Height,
                        Bats:         p.Bats,
                        Throws:       p.Throws,
                        Debut:        p.Debut.Format(layout),
                        FinalGame:    p.FinalGame.Format(layout),
                        RetroID:      p.RetroID,
                        BbrefID:      p.BbrefID,
                })

}</span>

func (p *Player) getDeathDates() (*int, *int, *int) <span class="cov8" title="1">{

        if p.DeathDate.IsZero() </span><span class="cov0" title="0">{
                return nil, nil, nil
        }</span>
        <span class="cov8" title="1">year := p.DeathDate.Year()
        day := p.DeathDate.Day()
        month := p.DeathDate.Month()
        monthConverted := int(month)
        return &amp;year, &amp;monthConverted, &amp;day</span>

}

func (p *Player) getBirthDates() (*int, *int, *int) <span class="cov8" title="1">{
        year := p.BirthDate.Year()
        day := p.BirthDate.Day()
        month := p.BirthDate.Month()
        monthConverted := int(month)
        return &amp;year, &amp;monthConverted, &amp;day
}</span>

func getString(s string) *string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;s</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package intuit

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/gorilla/mux"
)

type PlayerAPI struct {
        client *SQLClient
        mux    *mux.Router
}

func NewServer(config SQLConfig) (*PlayerAPI, error) <span class="cov0" title="0">{
        client, err := NewSQLClinet(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;PlayerAPI{
                client: client,
                mux:    mux.NewRouter(),
        }, nil</span>

}

func (p *PlayerAPI) registerRoutes() *mux.Router <span class="cov8" title="1">{
        p.mux.HandleFunc("/api/players", p.GetAllPlayers)
        p.mux.HandleFunc("/api/players/{id}", p.GetPlayById)
        return p.mux

}</span>

func (p *PlayerAPI) Start() <span class="cov0" title="0">{
        p.registerRoutes()
        srv := &amp;http.Server{
                Addr:         "0.0.0.0:8080",
                WriteTimeout: time.Second * 15,
                ReadTimeout:  time.Second * 15,
                IdleTimeout:  time.Second * 60,
                Handler:      p.mux,
        }

        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        }()

}

func (p *PlayerAPI) GetPlayById(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        values := mux.Vars(req)
        var player *Player
        var err error
        i, ok := values["id"]
        if ok </span><span class="cov8" title="1">{
                player, err = p.client.GetPlayerById(i)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(res, err.Error(), 500)
                        return
                }</span>
                <span class="cov8" title="1">if player == nil </span><span class="cov0" title="0">{
                        http.Error(res, fmt.Sprintf("player %v not found", i), 404)
                        return
                }</span>
                <span class="cov8" title="1">res.Header().Set("Content-Type", "application/json")
                enc := json.NewEncoder(res)

                enc.Encode(player)
                return</span>

        } else<span class="cov0" title="0"> {
                http.Error(res, "unable to parse request", 401)
                return
        }</span>

}

func (p *PlayerAPI) GetAllPlayers(res http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        res.Header().Set("Content-Type", "application/json")
        players, err := p.client.GetAllPlayers()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(res, err.Error(), 500)
                return
        }</span>

        <span class="cov0" title="0">enc := json.NewEncoder(res)

        enc.Encode(players)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
